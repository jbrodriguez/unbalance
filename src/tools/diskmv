#!/bin/bash
# diskmv - Move an unRAID user share directory from one disk to another
#
# usage: diskmv [options] directory srcdisk destdisk
#
# A find/rsync structure is used to copy files and directories and then 
# delete only if the copy succeed, similar to the unRAID mover script.

usage(){
cat << EOF

usage: diskmv [-t|-f|-k|-l|-c|-s N|-v|-q|-h] directory srcdisk destdisk

EOF
}

helpmsg(){
cat << EOF

usage: diskmv [options] directory srcdisk destdisk

directory    Any directory that is contained in the user share file system.
             It can be specified as an absolute or relative path and can be 
             relative to the current directory or the /mnt/user/ directory.  

srcdisk      Source disk which can be any valid disk in the unraid array. 
             Examples: 'disk2', 'disk18' or 'cache'.

destdisk     Destination disk which can be any valid disk in the unraid array.
             Examples: 'disk2', 'disk18' or 'cache'.

Options:

-t	test mode, do not copy or delete files
-f	force, override test mode and take action
-k	keep source files, do not delete after successful copy
-l	link, copy symlinks as symlinks, default is to ignore symlinks
-c	clobber, duplicates on destination will be overwritten
-s N    small, only move files less than or equal to N kilobytes
-e EXT  only move files with extensions in the comma separated list EXT
-v	verbose, output more information
-q	quiet, output less information
-h	help, print this help message

EOF
}

[ ${DEBUG:=0} -gt 0 ] && set -x -v

doit='false'      # Default to dry-run
keepsrc='false'   # Delete source files by default if copy works
symlinks='false'  # Default rsync to not copy symlinks as symlinks
clobber='false'   # Default to skip duplicates
small='false'     # Default to not limit file size
verbose=1	  # Default to output some but not all info

while :; do
  case "$1" in
    -h|-\?|--help)
      helpmsg
      exit 0
      ;;
    -t|--test) # Specify test mode where no files are moved
      doit='false'
      ;;
    -f|--force) # Override test mode and force action
      doit='true'
      ;;
    -k|--keepsource) # Do not delete any source files
      keepsrc='true'
      ;;
    -l|--links) # Copy symlinks as symlinks
      symlinks='true'
      ;;
    -c|--clobber) # Clobber duplicates on destination
      clobber='true'
      ;;
    -s|--small) # Only move files smaller than 4096 bytes
      small='true'
      maxsize="$2"
      shift
      ;;
    -e|--extension) # Only move files smaller than 4096 bytes
      extonly='true'
      extlist="$2"
      shift
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity
      ;;
    -q|--quiet)
      verbose=$((verbose - 1)) # Each -q argument subtracts 1 from verbosity
      ;;
    --) # End of all options
      break
      ;;
    -?*)
      echo "Unknown option (ignored): $1" >&2
      ;;
    *) # Default case: if no more options then break out of loop
      break
  esac
  shift
done

if [ "$extonly" == 'true' ]; then
  if [ -z "$extlist" ]; then
    echo "The -e (--extension) option requires a list of extensions." >&2
    usage >&2
    exit 1
  fi
fi

if [ "$small" == 'true' ]; then
  if [ -z "$maxsize" ]; then
    echo "The -s (--small) option requires an integer argument." >&2
    usage >&2
    exit 1
  fi
  re='^[1-9][0-9]*$'  #Regular expression for only digits not starting with 0
  if [[ ! "$maxsize" =~ $re ]]; then
    echo "Invalid argument: '$maxsize' for the -s (--small) option." >&2
    usage >&2
    exit 1
  fi
fi

if [ -d "$1" ]
then
  FULLNAME=$(readlink -e "$1")   # Handle relative path
  MERGEDIR="${FULLNAME#/mnt/*/}"   # Remove any /mnt/*/ prefix
else
  MERGEDIR="$1"
fi

# if [ ! -d "/mnt/user/$MERGEDIR" ]
# then 
#   echo "'$1' is not a valid user share directory." >&2
#   usage >&2
#   exit 1
# fi

if [ -z $2 -o -z $3 ]
then
  echo "Both source and destination disks must be specified."  >&2
  usage >&2
  exit 1
fi

SRCDISK="${2#/mnt/}"    #Remove any leading /mnt/ prefix
SRCDISK="${SRCDISK%%/*}"    #Remove any trailing path
if [[ ! -d "/mnt/$SRCDISK" \
     || "$SRCDISK" != disk[1-9] && "$SRCDISK" != disk[1-9][0-9] && "$SRCDISK" != "cache" \
   ]]
then
  echo "'$2' is not a valid disk." >&2
  usage >&2
  exit 1
fi

DESTDISK="${3#/mnt/}"    #Remove any leading /mnt/ prefix
DESTDISK="${DESTDISK%%/*}"    #Remove any trailing path
if [[ ! -d "/mnt/$DESTDISK" \
     || "$DESTDISK" != disk[1-9] && "$DESTDISK" != disk[1-9][0-9] && "$DESTDISK" != "cache" \
   ]]
then
  echo "'$3' is not a valid disk." >&2
  usage >&2
  exit 1
fi

RSYNCOPTS="-dIWRpEAXogtl --numeric-ids --inplace"
# rsync options used:
# -d, --dirs                  transfer directories without recursing
# -I, --ignore-times          don't skip files that match in size and mod-time
# -W, --whole-file            copy files whole (without delta-xfer algorithm)
# -R, --relative              use relative path names
# -p, --perms                 preserve permissions
# -E, --executability         preserve the file's executability
# -A, --acls                  preserve ACLs (implies --perms)
# -X, --xattrs                preserve extended attributes
# -o, --owner                 preserve owner (super-user only)
# -g, --group                 preserve group
# -t, --times                 preserve modification times
# -l, --links                 copy symlinks as symlinks
#     --numeric-ids           don't map uid/gid values by user/group name
#     --inplace               update destination files in-place

# rsync options set optionally below
# -i, --itemize-changes       output a change-summary for all updates

if [ $doit == 'true' ]; then
  if [ $keepsrc == 'false' ]; then
    DELCLAUSE="-delete"
  else
    DELCLAUSE=""
  fi
else
  echo "Running in test mode, no files will be moved."
  RSYNCOPTS="$RSYNCOPTS --dry-run"
  DELCLAUSE=""
fi

if [ $symlinks == 'true' ]; then
  SLCLAUSE="-o -type l"
else
  SLCLAUSE=""
fi

if [ $clobber == 'true' ]; then
  DUPCLAUSE=""
else
  # This duplicate clause as annoyingly complicated:
  # If the specified file is a directory on the destination disk or if the 
  #   specified file does not exist on the destination disk, then the duplicate
  #   clause is finished and the next clause in the find statement is processed.
  # Otherwise, some output is printed and false is returned so the rest of the
  #   clauses in the find statement are not processed and the file is not
  #   copied or moved.
  DUPCLAUSE=" \
      ( \
        -exec [ -d /mnt/$DESTDISK/{} ] ; \
        -o \
        -exec [ ! -e /mnt/$DESTDISK/{} ] ; \
        -o \
        -exec echo Duplicate skipped: {} ; \
        -a \
        -exec false ; \
      ) "
fi

if [ "$extonly" == 'true' ]; then
  EXTCLAUSE=('(')  #Start the extension clause with paren stored in an array
  THEREST="$extlist"   #Initialize THEREST
  while true; do
    EXT="${THEREST%%,*}"   #Get the first extension
    THEREST="${THEREST#*,}"   #Remove the first extension
    EXTCLAUSE+=( -name '*.'"$EXT" )  #Add a -name '*.EXT' test
    if [[ "$EXT" == "$THEREST" ]]; then  #There is only one ext left in the list
      EXTCLAUSE+=(')')  #finish off the extension clause with close paren
      break  #Done with the while loop
    fi
    EXTCLAUSE+=(-o)   #Add an "or" operator for the next extension
  done
else
  EXTCLAUSE=( )
fi

if [ "$small" == 'true' ]; then
  SIZECLAUSE="-size -$((maxsize*1024+1))c"
else
  SIZECLAUSE=""
fi

if [ $verbose -gt 0 ]; then
  PRINTCLAUSE="-print"
else
  PRINTCLAUSE=""
fi

if [ $verbose -gt 1 ]; then
  RSYNCOPTS="$RSYNCOPTS -i"
fi

echo "Moving /mnt/$SRCDISK/$MERGEDIR into /mnt/$DESTDISK/$MERGEDIR"
cd "/mnt/$SRCDISK"

find "./$MERGEDIR" -depth \
      \( \
        \( -type f $SIZECLAUSE "${EXTCLAUSE[@]}" ! -exec fuser -s {} \; \) \
        -o \
        \( -type d -empty \) \
        $SLCLAUSE \
      \) \
      $PRINTCLAUSE \
      $DUPCLAUSE \
      -exec rsync $RSYNCOPTS {} "/mnt/${DESTDISK}/" \; \
      $DELCLAUSE

echo "diskmv finished"

if [ ! $doit == 'true' ]; then
  echo "... but it ran in test mode"
fi

echo " "